package com.foursquare.heapaudit;

import com.sun.tools.attach.VirtualMachine;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

// When loaded statically via the java command line as a java agent, the main
// entry point is HeapAudit.premain(). When loaded dynamically, the java command
// line first invokes HeapAudit.main() which then causes the JVM to load the
// java agent (the same jar file) into the target process.

public class HeapAudit extends HeapUtil implements ClassFileTransformer {

    static {
        /*
        Runtime.getRuntime().addShutdownHook(new Thread() {

                @Override public void run() {

                    HeapRecorder.instrumentation = null;

                }

            });
        */
    }

    // The following is the wrapper that instructs JVM to load the java agent
    // into the designated target process.

    public static void main(String[] args) throws Exception {

        StringBuffer s = new StringBuffer("-Xconditional");

        boolean o = false;

        for (int i = 1; i < args.length; ++i) {

            s.append(' ');

            s.append(args[i]);

            if (args[i].startsWith("-O")) {

                o = true;

            }

        }

        // The following instructs the java agent to write to a temporary file
        // if an output file has not already been specified. This is necessary
        // because the java agent runs in the injectee's JVM while the injector
        // runs in a separate JVM. The injectee will not be able to directly
        // write the output to the injector's console.

        File file = null;

        if (!o) {

            file = File.createTempFile("heapaudit",
                                       "out");

            s.append(" -O" + file.getAbsolutePath());

        }

        load(args[0],
             s.toString());

        // If the output file was not explicitly specified, display content of
        // the temporary file generated by the injectee to the injector's
        // console.

        if (!o) {

            BufferedReader input = new BufferedReader(new FileReader(file.getAbsolutePath()));

            char[] buffer = new char[4096];

            int length = 0;

            while ((length = input.read(buffer)) != -1) {

                System.out.println(String.valueOf(buffer,
                                                  0,
                                                  length));

            }

            file.delete();

        }

    }

    // The following attaches to the specified process and loads the java agent,
    // which happens to be the same jar file itself.

    public static void load(String pid,
                            String args) throws Exception {

        VirtualMachine vm = VirtualMachine.attach(pid);

        vm.loadAgent(HeapAudit.class.getProtectionDomain().getCodeSource().getLocation().getPath(),
                     args);

        vm.detach();

    }

    // The following is the entry point when loaded dynamically to inject or
    // remove recorders from the target process. 

    public static void agentmain(String args,
                                 Instrumentation instrumentation) throws FileNotFoundException, UnmodifiableClassException {

        instrument(args,
                   instrumentation,
                   true);

    }

    // The following is the entry point when loaded as a java agent along with
    // the target process on the java command line.

    public static void premain(String args,
                               Instrumentation instrumentation) throws FileNotFoundException, UnmodifiableClassException {

        instrument(args,
                   instrumentation,
                   false);

    }

    // The following is the implementation for instrumenting the target code.

    private static void instrument(String args,
                                   Instrumentation instrumentation,
                                   boolean dynamic) throws FileNotFoundException, UnmodifiableClassException {

        HeapSettings.parse(args,
                           dynamic);
        
        HeapRecorder.isAuditing = true;

        HeapRecorder.instrumentation = instrumentation;

        ClassFileTransformer transformer = new HeapAudit();

        instrumentation.addTransformer(transformer,
                                       true);

        if (instrumentation.isRetransformClassesSupported()) {

            ArrayList<Class<?>> classes = new ArrayList<Class<?>>();

            for (Class<?> c: instrumentation.getAllLoadedClasses()) {

                if (instrumentation.isModifiableClass(c)) {

                    classes.add(c);

                }

            }

            instrumentation.retransformClasses(classes.toArray(new Class<?>[classes.size()]));

        }

        if (dynamic) {

            instrumentation.removeTransformer(transformer);

        }

    }

    // The following is the main entry point for transforming the bytecode.

    public byte[] transform(ClassLoader loader,
                            String className,
                            Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain,
                            byte[] classfileBuffer) {

        if (HeapSettings.shouldAvoidAuditing(className, null) &&
            !HeapSettings.shouldInjectRecorder(className, null) &&
            !HeapSettings.shouldRemoveRecorder(className, null)) {

            return null;

        }

        ClassReader cr = new ClassReader(classfileBuffer);

        ClassWriter cw = new ClassWriter(cr,
                                         ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);

        cr.accept(new HeapClass(cw,
                                className,
                                HeapSettings.shouldDebugAuditing(className, null)),
                  ClassReader.SKIP_FRAMES);

        return cw.toByteArray();

    }

}
