package com.foursquare.heapaudit;

import com.sun.tools.attach.VirtualMachine;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;
import java.nio.channels.FileLock;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

// When loaded statically via the java command line as a java agent, the main
// entry point is HeapAudit.premain(). When loaded dynamically, the java command
// line first invokes HeapAudit.main() which then causes the JVM to load the
// java agent (the same jar file) into the target process.

public class HeapAudit extends HeapUtil implements ClassFileTransformer {

    static {
        /*
        Runtime.getRuntime().addShutdownHook(new Thread() {

                @Override public void run() {

                    HeapRecorder.instrumentation = null;

                }

            });
        */
    }

    // The following is the wrapper that instructs JVM to load the java agent
    // into the designated target process.

    public static void main(String[] args) throws Exception {

        StringBuffer s = new StringBuffer("-Xconditional");

        boolean o = false;

        File file = null;

        for (int i = 1; i < args.length; ++i) {

            s.append(' ');

            s.append(args[i]);

            if (args[i].startsWith("-O")) {

                o = true;

                file = new File(args[i].substring(2));

            }

        }

        // The following instructs the java agent to write to a temporary file
        // if an output file has not already been specified. This is necessary
        // because the java agent runs in the injectee's JVM while the injector
        // runs in a separate JVM. The injectee will not be able to directly
        // write the output to the injector's console.

        if (!o) {

            file = File.createTempFile("heapaudit",
                                       "out");

            s.append(" -O" + file.getAbsolutePath());

        }

        // The following attaches to the specified process and dynamically
        // injects recorders to collect heap allocation activities. The
        // collection continues until the user presses enter at the command
        // line. Because we are dealing with two separate JVM instances, the
        // following logic relies on a file lock to signal when the collection
        // should terminate.

        VirtualMachine vm = VirtualMachine.attach(args[0]);

        final FileLock lock = (new FileOutputStream(file)).getChannel().lock();

        (new Thread(new Runnable() {

            public void run() {

                try {

                    System.console().readLine("Press <enter> to exit HeapAudit...");

                    lock.release();

                }
                catch (Exception e) {

                }

            }

        })).start();

        vm.loadAgent(HeapAudit.class.getProtectionDomain().getCodeSource().getLocation().getPath(),
                     s.toString());

        vm.detach();

        // If the output file was not explicitly specified, display content of
        // the temporary file generated by the injectee to the injector's
        // console.

        if (!o) {

            BufferedReader input = new BufferedReader(new FileReader(file.getAbsolutePath()));

            char[] buffer = new char[4096];

            int length = 0;

            while ((length = input.read(buffer)) != -1) {

                System.out.println(String.valueOf(buffer,
                                                  0,
                                                  length));

            }

            file.delete();

        }

    }

    private static void initialize(String args,
                                   Instrumentation instrumentation,
                                   boolean dynamic) throws FileNotFoundException {

        HeapSettings.parse(args,
                           dynamic);

        HeapRecorder.isAuditing = true;

        HeapRecorder.instrumentation = instrumentation;

    }

    // The following is the entry point when loaded dynamically to inject
    // recorders from the target process. 

    public static void agentmain(String args,
                                 Instrumentation instrumentation) throws FileNotFoundException, IOException, UnmodifiableClassException {

        initialize(args,
                   instrumentation,
                   true);

        HeapAudit agent = new HeapAudit();

        instrument(agent,
                   args,
                   instrumentation);

        // Block until user hits enter from command line.

        HeapSettings.lock.lock();

        instrumentation.removeTransformer(agent);

        HeapAudit cleanup = new HeapAudit() {

            public byte[] transform(ClassLoader loader,
                                    String className,
                                    Class<?> classBeingRedefined,
                                    ProtectionDomain protectionDomain,
                                    byte[] classfileBuffer) {

                // Returning null causes the class definition to be restored
                // back to the original byte codes.

                return null;

            }

        };

        instrument(cleanup,
                   args,
                   instrumentation);

        instrumentation.removeTransformer(cleanup);

        HeapUtil.dump();

    }

    // The following is the entry point when loaded as a java agent along with
    // the target process on the java command line.

    public static void premain(String args,
                               Instrumentation instrumentation) throws FileNotFoundException, UnmodifiableClassException {

        initialize(args,
                   instrumentation,
                   false);

        instrument(new HeapAudit(),
                   args,
                   instrumentation);

    }

    // The following is the implementation for instrumenting the target code.

    private static void instrument(HeapAudit agent,
                                   String args,
                                   Instrumentation instrumentation) throws FileNotFoundException, UnmodifiableClassException {

        if (!instrumentation.isRetransformClassesSupported()) {

            throw new UnmodifiableClassException();

        }

        instrumentation.addTransformer(agent,
                                       true);

        ArrayList<Class<?>> classes = new ArrayList<Class<?>>();

        for (Class<?> c: instrumentation.getAllLoadedClasses()) {

            if (instrumentation.isModifiableClass(c)) {

                classes.add(c);

            }

        }

        instrumentation.retransformClasses(classes.toArray(new Class<?>[classes.size()]));

    }

    // The following is the main entry point for transforming the bytecode.

    public byte[] transform(ClassLoader loader,
                            String className,
                            Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain,
                            byte[] classfileBuffer) {

        byte[] buffer = null;

        boolean shouldSuppressAuditing = HeapSettings.shouldSuppressAuditing(className, null);

        boolean shouldAvoidAuditing = HeapSettings.shouldAvoidAuditing(className, null);

        boolean shouldDebugAuditing = HeapSettings.shouldDebugAuditing(className, null);

        boolean shouldInjectRecorder = HeapSettings.shouldInjectRecorder(className, null);

        if (shouldSuppressAuditing ||
            !shouldAvoidAuditing ||
            shouldInjectRecorder) {

            ClassReader cr = new ClassReader(classfileBuffer);

            ClassWriter cw = new ClassWriter(cr,
                                             ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);

            cr.accept(new HeapClass(cw,
                                    className,
                                    shouldSuppressAuditing,
                                    shouldDebugAuditing),
                      ClassReader.SKIP_FRAMES);

            buffer = cw.toByteArray();

        }

        return buffer;

    }

}
